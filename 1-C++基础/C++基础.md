# C++基础

## 基础语法
### 1、static与普通变量的区别？常量存储在哪里？static变量又是存储在哪里？
* static与普通auto变量相比，static强调唯一一份，内存里只有一份拷贝。  
* static修饰函数变量，在下次调用该函数时，static变量维持上次调用得到的值。  
* static修饰模块，即static修饰的模块中的作用范围仅限于该模块。  
* static修饰类成员变量，static成员变量属于整个类所有，而不依赖于类的实例。  
* static变量存储在全局/静态存储区

### 2、const和static关键字用法
static见1，const强调不变，不变的变量，即常量，static强调独一份。  
* const修饰普通变量，则不能改变其值。  
* const修饰函数的形参，使得函数不能改变参数的值。  
* const修饰类的成员函数，表明该成员函数不会修改成员变量的值，如果想要在const的成员函数中修改成员变量，则成员变量需添加mutable关键字。  
* const修饰的类的成员变量需要在初始化列表中初始化，static修饰的类的成员变量需要在类外去做初始化，当然也有例外例如简单的内置数据类型int可以在类中直接初始化。  
》》那么底层是如何保证const变量不会被改变呢？  


## 面向对象
### 1、C++面向对象的特性
封装、继承和多态  
封装，隐藏实现细节，实现代码模块化  
继承，派生类继承基类的成员函数和成员变量，实现代码的重用。  
多态，即一个接口多种实现，利用虚函数，派生类override基类的虚函数。  

### 2、一个类声明的时候默认有哪些东西？
默认构造函数、析构函数、拷贝赋值构造函数，移动赋值构造函数、拷贝赋值运算符和移动赋值运算符。  

### 3、构造函数能不能是虚函数，原因：
构造函数不能是虚函数  
<font color=#ff000>TODO 更具体的答案</font>

### 4、虚析构函数及其作用？
当一个基类指针指向一个派生类对象，delete该基类指针时，会先执行派生类的析构函数，然后再执行基类的析构函数，如果没有把析构函数设置为虚函数，则会先执行基类的析构函数，容易造成内存泄漏。  

### 5、虚函数与纯虚函数的区别
纯虚函数仅提供一个函数接口，不提供具体实现，带有纯虚函数的类也称为抽象类，抽象类不能直接实例化，而是由派生类继承抽象类，overrider虚函数，完成虚函数的实现。  

## STL标准库
### 1、STL中vector和map底层原理
vector底层是一块连续的内存，类似于array或者数组，但是vector的大小是可变的，vector在VS下是1.5倍扩容，在GCC下是2倍扩容，写操作的时间复杂度是O(1)，读操作的时间复杂度也是O(1)，一般如果能预估vector中元素的大小，建议使用resize或者reserve先调整vector的大小，在使用vector时会有一定的性能提升。  
map底层是颗红黑树，红黑树是由红色节点和黑色节点组合，根节点一定是黑节点，红节点的子节点一定是黑节点，任意节点到它下面的叶子节点（NULL节点）经过黑节点数量相同，插入时最多旋转三次。  

## 编译原理
### 1、简述C++编译过程
预处理、编译、汇编、链接。预处理（完成一些预处理指令）进行一些代码的替换和插入等，编译将代码编译成汇编代码，汇编将汇编代码生成机器指令，链接则是利用汇编后得到的文件生成可执行文件。  

## GCC命令
-c，只编译，不链接成可执行文件，编译器只是由输入的.c等源代码文件生成.o为后缀的目标文件，通常编译不含主程序的子程序文件。  
-o output_filename，确定输出文件的名称为output_filename，同时这个名称不能和源文件同名，如果不给出这个选项gcc就给出预设的可执行文件a.out  
-g，产生符号调试工具（GNU的gdb）所必要的符号咨讯，要想对源代码进行调试，我们就必须加入这个选项。  
-O，对程序进行优化编译、链接，采用这个选项，整个源代码会在编译、链接过程中进行优化处理，这样产生的可执行文件的执行效率可以提高，但是，编译、链接的速度就相应地要慢一些。  
-O2，比-O更好的优化编译、链接，当然整个编译、链接过程会更慢。  
-l dirname，将dirname所指出的目录加入到程序头文件目录列表中，是在预编译过程中使用的参数。  
